RISC architecture

registers numbered r0-r31, with some special
r0 - always set to 0

instruction layout
(open form)
OOOOOOO ***** rrrrr RRRRR EEEEEEEEEE

O - opcode
* - register 1 bits
r - register 2 bits
R - register 3 bits
E - operand/extra bits

note: the instruction may appear like this if there is
only one register in the instruction (e.g ldli)

(word form)
OOOOOOO* ****----
EEEEEEEE EEEEEEEE


 op  | mnemonic |      inputs     |        function
-----+----------+-----------------+-----------------------------------------
0x0  |   ldli   | reg  imm            |  loads imm into the lower half of reg
0x1  |   ldhi   | reg  imm            |  loads imm into the upper half of reg
0x2  |   load   | reg1 reg2 imm       |  reg2 = *(reg1 + imm) (where imm is sign extended to 32 bits)
0x3  |   sthi   | reg  imm            |  loads the upper half of the store address
0x4  |   stli   | reg  imm            |  stores reg into imm (including the upper stored by sthi)
0x5  |   sth    | reg  imm            |  loads the upper half of the store address
0x6  |   stl    | reg  imm            |  stores reg into *imm (including the upper stored by sth)
0x7  |   add    | reg1 reg2 reg3      |  reg3 = reg1 + reg2
0x8  |   sub    | reg1 reg2 reg3      |  reg3 = reg1 - reg2
0x9  |   or     | reg1 reg2 reg3      |  reg3 = reg1 | reg2
0xA  |   and    | reg1 reg2 reg3      |  reg3 = reg1 & reg2
0xB  |   xor    | reg1 reg2 reg3      |  reg3 = reg1 ^ reg2
0xC  |   not    | reg1 reg2           |  reg2 = ~reg1
0xD  |   lsl    | reg1 reg2 n         |  reg2 = reg1 << n (logical shift left)
0xE  |   lsr    | reg1 reg2 n         |  reg2 = reg1 >> n (logical shift right)
0xF  |   jalcc  | reg1 reg2 reg3 reg4 |  jump and link condition - if condition is satisfied then
     |          |                     |        store return addr in reg1 and 
     |          |                     |        jump to value in reg2
0x10 |   cmp    | reg1 reg2           |  compares r1 and r2
     |          |                     |        sets L = 1 if r1 < r2
     |          |                     |        sets E = 1 if r1 == r2
     |          |                     |        sets G = 1 if r1 > r2
0x11 |   clr    |                     |  clear all arithmetic flags
later opcodes to be used for mmio, mapping and multitasking 


JALCC

the extra 5 bits of JALCC can be used to get all of the conditions below
NJJJJ

J - defines the JAL mode
JALEQ - J = 0 (equal)
JALG  - J = 1 (greater than)
JALL  - J = 2 (less than)
JALGS - J = 3 (greater than signed)
JALLS - J = 4 (less than signed)

N - sets negation
N = 0
JALNEQ
JALNG
JALNL